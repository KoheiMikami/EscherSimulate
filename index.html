<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <title>EscherSimulator</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    h1 {
      width: 960px;
      margin: 0 auto;
      margin-top: 20px;
      margin-bottom: 30px;
    }

    #stage {
      width: 960px;
      margin: 0 auto;
    }
  </style>
</head>

<body>
  <h1>EscherSimulate</h1>
  <div id="stage"></div>
  <script src="three.min.js"></script>
  <script src="perlin-noise-simplex.js"></script>

  <script>
    Line = function() {
      this.curveObject;
      this.startPos = {x:0,y:0};
      this.endPos = {x:0,y:0};
      this.pos = {x:0,y:0};
      this.count;
      this.startPosArr = [];
      this.endPosArr = [];
      this.pct = 0;
      this.isAnimation = false;
    };
    Line.prototype.createLine = function() {
      var curve = new THREE.CubicBezierCurve3(
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(100, 0, 0),
        new THREE.Vector3(200, 0, 0),
        new THREE.Vector3(300, 0, 0)
      );

      this.curveObject = new THREE.Line((function() {
        var geometry = new THREE.Geometry();
        geometry.vertices = curve.getPoints(5);
        return geometry;
      })(), new THREE.LineBasicMaterial({
        color: 0xffffff
      }));

      return this.curveObject;
    };

    Line.prototype.vertexOp = function(val) {
      this.curveObject.geometry.verticesNeedUpdate = true

      for (i = 0; i < this.curveObject.geometry.vertices.length; i++) {
        var vertex = this.curveObject.geometry.vertices[i];
        vertex.y = val[i];
      }
    };

    Line.prototype.setNoiseVal = function(val) {
      this.vertexOp(val);
    };

    Line.prototype.setStartPos = function (val) {
      this.vertexOp(val);
      this.isAnimation = false;
      this.startPosArr.length = 0;
      for (var i = 0; i < this.curveObject.geometry.vertices.length; i++) {
        this.startPosArr.push(val[i]);
      }
    };

    Line.prototype.setEndPos = function (val) {
      this.isAnimation = true;
      this.endPosArr.length = 0;
      for (var i = 0; i < this.curveObject.geometry.vertices.length; i++) {
        this.endPosArr.push(val[i]);
      }
    };
    Line.prototype.getPct = function () {
      return this.pct;
    };

    Line.prototype.interpolateByPct = function(pct) {
      var arr = [];
      for (var i = 0; i < this.curveObject.geometry.vertices.length; i++) {
        arr.push((1.0 - pct) * this.startPosArr[i] + (pct) * this.endPosArr[i]);
      }
      return arr;
    };
    Line.prototype.vertexPctUpdate = function() {
      if (this.isAnimation) {
        this.pct += 0.1;

        if (this.pct > 1.0) {
          var array = [0,0,0,0,0,0];
          this.setStartPos(this.interpolateByPct(this.pct));
          this.pct = 0.0;
          this.isAnimation = false;
        }else{
          this.vertexOp(this.interpolateByPct(this.pct));
        }
      }


    };

    var syousuten2ika = function(val) {
      var val2 = val;
      val2 *= 10;
      val2 = Math.floor(val);
      val2 /= 10;
      return val2;
    };

    var isInteger = function (val) {
      var enumArr = ["true", "none", "false"];
      if (val > 0) {
        return enumArr[0];
      } else if (val < 0) {
        return enumArr[2];
      }else{
        return enumArr[1];
      }
    };

    (function() {
      var width = 960;
      var height = 540;
      var light;
      var camera;
      var ambient;
      var axis;
      var scene = new THREE.Scene();
      var displayObj = [];
      camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
      camera.position.set(0, 0, 800);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 100, 30);
      scene.add(light);
      ambient = new THREE.AmbientLight(0x550000);
      scene.add(ambient);

      axis = new THREE.AxisHelper(1500);
      axis.position.set(0, 0, 0);
      //scene.add(axis);

      var line = new Line();
      var modelLine = line.createLine();
      scene.add(modelLine);

      var simpleNoise = new SimplexNoise;

      //頂点に初期値を与える
      var noiseArr = [];
      for (var i = 0; i < modelLine.geometry.vertices.length; i++) {

        var vertex = modelLine.geometry.vertices[i];
        var randomNoise = simpleNoise.noise(vertex.x / 20, vertex.y / 20) * 100;
        noiseArr.push(syousuten2ika(randomNoise));

      }
      line.setStartPos(noiseArr);

      //setInterval
      setInterval(function() {

        var endNoiseArr = [];
        var date = new Date();
        console.log((date.getSeconds()+1));
        for (var i = 0; i < modelLine.geometry.vertices.length; i++) {
          var vertex = modelLine.geometry.vertices[i];
          endNoiseArr.push(simpleNoise.noise(vertex.x / (date.getSeconds()+1), vertex.y / (date.getSeconds()+1)) * 100);
        }

        if (line.getPct() == 0) {
          line.setEndPos(endNoiseArr);
        }

      }, 1000);


      //rendering
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(width, height);
      renderer.setClearColor(0x000000, 1);
      document.getElementById('stage').appendChild(renderer.domElement);

      var render = function() {
        requestAnimationFrame(render);
        renderer.render(scene, camera);
        line.vertexPctUpdate();

      };
      render();

    })();
  </script>

</body>

</html>
